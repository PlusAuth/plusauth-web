(function(a,u){typeof exports=="object"&&typeof module<"u"?u(exports):typeof define=="function"&&define.amd?define(["exports"],u):(a=typeof globalThis<"u"?globalThis:a||self,u(a.plusauthweb={}))})(this,function(a){"use strict";var k=Object.defineProperty;var M=(a,u,d)=>u in a?k(a,u,{enumerable:!0,configurable:!0,writable:!0,value:d}):a[u]=d;var w=(a,u,d)=>(M(a,typeof u!="symbol"?u+"":u,d),d);function u(e){return new TextEncoder().encode(e)}function d(e){const t=new Uint8Array(e);let n="";for(const i of t)n+=String.fromCharCode(i);return btoa(n).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function g(e){const t=e.replace(/-/g,"+").replace(/_/g,"/"),n=(4-t.length%4)%4,r=t.padEnd(t.length+n,"="),i=atob(r),s=new ArrayBuffer(i.length),o=new Uint8Array(s);for(let l=0;l<i.length;l++)o[l]=i.charCodeAt(l);return s}function b(){return(window==null?void 0:window.PublicKeyCredential)!==void 0&&typeof window.PublicKeyCredential=="function"}function A(e){const{id:t}=e;return{...e,id:g(t),transports:e.transports}}function E(e){return e==="localhost"||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(e)}class c extends Error{constructor(t,n="WebAuthnError"){super(t),this.name=n}}function D({error:e,options:t}){var n,r;const{publicKey:i}=t;if(!i)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal===new AbortController().signal)return new c("Registration ceremony was sent an abort signal","AbortError")}else if(e.name==="ConstraintError"){if(((n=i.authenticatorSelection)===null||n===void 0?void 0:n.requireResidentKey)===!0)return new c("Discoverable credentials were required but no available authenticator supported it","ConstraintError");if(((r=i.authenticatorSelection)===null||r===void 0?void 0:r.userVerification)==="required")return new c("User verification was required but no available authenticator supported it","ConstraintError")}else{if(e.name==="InvalidStateError")return new c("The authenticator was previously registered","InvalidStateError");if(e.name==="NotAllowedError")return new c("User clicked cancel, or the registration ceremony timed out","NotAllowedError");if(e.name==="NotSupportedError")return i.pubKeyCredParams.filter(o=>o.type==="public-key").length===0?new c('No entry in pubKeyCredParams was of type "public-key"',"NotSupportedError"):new c("No available authenticator supported any of the specified pubKeyCredParams algorithms","NotSupportedError");if(e.name==="SecurityError"){const s=window.location.hostname;if(E(s)){if(i.rp.id!==s)return new c(`The RP ID "${i.rp.id}" is invalid for this domain`,"SecurityError")}else return new c(`${window.location.hostname} is an invalid domain`,"SecurityError")}else if(e.name==="TypeError"){if(i.user.id.byteLength<1||i.user.id.byteLength>64)return new c("User ID was not between 1 and 64 characters","TypeError")}else if(e.name==="UnknownError")return new c("The authenticator was unable to process the specified options, or could not create a new credential","UnknownError")}return e}class R{createNewAbortSignal(){return this.controller&&this.controller.abort("Cancelling existing WebAuthn API call for new one"),this.controller=new AbortController,this.controller.signal}}const v=new R;async function x(e){if(!b())throw new Error("WebAuthn is not supported in this browser");const n={publicKey:{...e,challenge:g(e.challenge),user:{...e.user,id:u(e.user.id)},excludeCredentials:e.excludeCredentials.map(A)}};n.signal=v.createNewAbortSignal();let r;try{r=await navigator.credentials.create(n)}catch(p){throw D({error:p,options:n})}if(!r)throw new Error("Registration was not completed");const{id:i,rawId:s,response:o,type:l}=r,f={id:i,rawId:d(s),response:{attestationObject:d(o.attestationObject),clientDataJSON:d(o.clientDataJSON)},type:l,clientExtensionResults:r.getClientExtensionResults(),authenticatorAttachment:r.authenticatorAttachment};return typeof o.getTransports=="function"&&(f.transports=o.getTransports()),f}function U(e){return new TextDecoder("utf-8").decode(e)}async function S(){if(navigator.credentials.conditionalMediationSupported)return!0;const e=window.PublicKeyCredential;return e.isConditionalMediationAvailable!==void 0&&e.isConditionalMediationAvailable()}function W({error:e,options:t}){var n;const{publicKey:r}=t;if(!r)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal===new AbortController().signal)return new c("Authentication ceremony was sent an abort signal","AbortError")}else{if(e.name==="NotAllowedError")return!((n=r.allowCredentials)===null||n===void 0)&&n.length?new c("No available authenticator recognized any of the allowed credentials","NotAllowedError"):new c("User clicked cancel, or the authentication ceremony timed out","NotAllowedError");if(e.name==="SecurityError"){const i=window.location.hostname;if(E(i)){if(r.rpId!==i)return new c(`The RP ID "${r.rpId}" is invalid for this domain`,"SecurityError")}else return new c(`${window.location.hostname} is an invalid domain`,"SecurityError")}else if(e.name==="UnknownError")return new c("The authenticator was unable to process the specified options, or could not create a new assertion signature","UnknownError")}return e}async function _(e,t=!1){var n,r;if(!b())throw new Error("WebAuthn is not supported in this browser");let i;((n=e.allowCredentials)===null||n===void 0?void 0:n.length)!==0&&(i=(r=e.allowCredentials)===null||r===void 0?void 0:r.map(A));const s={...e,challenge:g(e.challenge),allowCredentials:i},o={};if(t){if(!await S())throw Error("Browser does not support WebAuthn autofill");if(document.querySelectorAll("input[autocomplete*='webauthn']").length<1)throw Error('No <input> with `"webauthn"` in its `autocomplete` attribute was detected');o.mediation="conditional",s.allowCredentials=[]}o.publicKey=s,o.signal=v.createNewAbortSignal();let l;try{l=await navigator.credentials.get(o)}catch(T){throw W({error:T,options:o})}if(!l)throw new Error("Authentication was not completed");const{id:f,rawId:p,response:h,type:y}=l;let K;return h.userHandle&&(K=U(h.userHandle)),{id:f,rawId:d(p),response:{authenticatorData:d(h.authenticatorData),clientDataJSON:d(h.clientDataJSON),signature:d(h.signature),userHandle:K},type:y,clientExtensionResults:l.getClientExtensionResults(),authenticatorAttachment:l.authenticatorAttachment}}async function $(){return b()?PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable():!1}function C(e,t){return new Promise(function(n,r){fetch(e,t).then(i=>{const s=i.headers.get("content-type");let o=null;i.text().then(l=>{if(s&&s.indexOf("application/json")>-1?o=Object.assign(JSON.parse(l),{_raw:i}):o={data:l,_raw:i},i.ok)n(o);else{if(i.status===400&&o.error==="xhr_request"&&o.location)return window.location.replace(o.location),!1;r(o)}})}).catch(r)})}class m{constructor(t,n){w(this,"http");w(this,"constructor");const r={};["get","post","patch","delete"].forEach(i=>{r[i]=function(...s){const o=Object.assign({method:i,credentials:"include",mode:"cors"},n||{});return o.headers=Object.assign({"Content-Type":"application/json",Accept:"application/json","X-Requested-With":"XMLHttpRequest"},o.headers||{}),i!=="get"&&(o.body=JSON.stringify(s[1])),typeof s[0]!="string"?C.call(null,t,o):C.call(null,t+s[0],o)}}),this.http=r}}class P extends m{constructor(t){super(t)}signIn(t,n){return this.http.post("/signin",{...t,strategy:n})}signUp(t,n){return this.http.post("/signup",{...t,strategy:n})}updateMissingInformation(t){return this.http.post("/account/updateMissingInformation",t)}requestResetPassword(t){return this.http.post("/account/forgotPassword",{email:t})}resetPassword(t,n){return this.http.post(`/account/resetPassword/${n}`,{password:t})}acceptConsent(){return this.http.post("/signin/consent/confirm")}rejectConsent(){return this.http.get("/signin/consent/reject")}checkPasswordStrength(t,n={}){t=t!=null?t:"";const r={};let{min:i,max:s,number:o,lowerCase:l,upperCase:f,customChars:p,customRegexp:h}=n;return l=Number(l),f=Number(f),o=Number(o),l&&!new RegExp(`(?=(.*[a-z])${l>0?`{${l},}`:""})`).test(t)&&(r.lowerCase=!0),f&&!new RegExp(`(?=(.*[A-Z])${f>0?`{${f},}`:""})`).test(t)&&(r.upperCase=!0),o&&!new RegExp(`(?=(.*[0-9])${o>0?`{${o},}`:""})`).test(t)&&(r.number=!0),i!=null&&t.length<i&&(r.min=!0),s!=null&&t.length>s&&(r.max=!0),p&&!p.split("").some(y=>t.indexOf(y)>-1)&&(r.customChars=!0),h&&h.value&&!new RegExp(h).test(h.value)?h.message||" ":Object.keys(r).length>0?r:!0}}class N extends m{constructor(t){super(t)}async validateCode(t,n){return this.http.post(`/signin/challenge/${n}`,{code:t})}}var I=(e=>(e.SMS="sms",e.EMAIL="email",e.SMARTCARD="sc",e.WEBAUTHN="webauthn",e.FINGER_VEIN="fv",e.OTP="otp",e))(I||{});class j{constructor(t){w(this,"auth");w(this,"mfa");try{t==="/"||new URL(t)}catch{throw new Error('"apiURL" must be a valid URL')}this.auth=new P(t),this.mfa=new N(t)}}a.AuthService=P,a.HttpService=m,a.MFACodeType=I,a.MFAService=N,a.PlusAuthWeb=j,a.isPlatformAuthenticatorAvailable=$,a.isWebAuthNAutofillSupported=S,a.isWebAuthNSupported=b,a.registerDevice=x,a.verifyDevice=_,Object.defineProperties(a,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
//# sourceMappingURL=plusauth-web.umd.js.map
